const asType = (type, opts = {}) => value => ({ type, value, ...opts });
const deferredType = (type, opts = {}) => {
  const typeFn = asType (type, opts);
  return typeFn (typeFn);
};

const deepCopy = o => {
  if (Array.isArray(o)) {
    return o.map(deepCopy);
  }
  if (Object.prototype.toString.call(o) === '[object Object]') {
    return Object.entries(o).reduce((acc, [k, v]) => {
      acc[k] = deepCopy(v);
      return acc;
    }, {});
  }
  return o;
}

const partition = (pred, a) => a.reduce((acc, cur) => {
  if (pred(cur)) {
    acc[0].push(cur);
  } else {
    acc[1].push(cur);
  }
  return acc;
}, [[], []]);

const specialChars = '\\.^$|?*+()[]{}-'.split('');
const replaceAll = (s, find, replace) => s.replace(new RegExp(`\\${find}`, 'g'), replace);
const escapeSpecial = s => specialChars.reduce((acc, char) => replaceAll(acc, char, `\\${char}`), s);

const namedGroupRegex = /^[a-z]+\w*$/i;

const quantifierTable = {
  oneOrMore: '+',
  oneOrMoreLazy: '+?',
  zeroOrMore: '*',
  zeroOrMoreLazy: '*?',
  optional: '?',
  exactly: metadata => `{${metadata}}`,
  atLeast: metadata => `{${metadata},}`,
  between: metadata => `{${metadata[0]},${metadata[1]}}`,
  betweenLazy: metadata => `{${metadata[0]},${metadata[1]}}?`,
}

const t = {
  root: asType('root') (),
  startOfInput: asType('startOfInput') (),
  endOfInput: asType('endOfInput') (),
  capture: deferredType('capture'),
  namedCapture: name => deferredType('namedCapture', { metadata: name }),
  namedBackreference: name => deferredType('namedBackreference', { metadata: name }),
  backreference: index => deferredType('backreference', { metadata: index }),
  group: deferredType('group'),
  anyOf: deferredType('anyOf'),
  assertAhead: deferredType('assertAhead'),
  assertNotAhead: deferredType('assertNotAhead'),
  exactly: times => deferredType('exactly', { metadata: times }),
  atLeast: times => deferredType('atLeast', { metadata: times }),
  between: (x, y) => deferredType('between', { metadata: [x, y] }),
  betweenLazy: (x, y) => deferredType('betweenLazy', { metadata: [x, y] }),
  anyChar: asType('anyChar') (),
  whitespaceChar: asType('whitespaceChar') (),
  nonWhitespaceChar: asType('nonWhitespaceChar') (),
  digit: asType('digit') (),
  nonDigit: asType('nonDigit') (),
  word: asType('word') (),
  nonWord: asType('nonWord') (),
  wordBoundary: asType('wordBoundary') (),
  nonWordBoundary: asType('nonWordBoundary') (),
  newline: asType('newline') (),
  carriageReturn: asType('carriageReturn') (),
  tab: asType('tab') (),
  nullByte: asType('nullByte') (),
  string: asType('string', { quantifierRequiresGroup: true }),
  anyOfChars: asType('anyOfChars'),
  anythingButString: asType('anythingButString'),
  anythingButChars: asType('anythingButChars'),
  anythingButRange: asType('anythingButRange'),
  char: asType('char'),
  range: asType('range'),
  zeroOrMore: deferredType('zeroOrMore'),
  zeroOrMoreLazy: deferredType('zeroOrMoreLazy'),
  oneOrMore: deferredType('oneOrMore'),
  oneOrMoreLazy: deferredType('oneOrMoreLazy'),
  optional: deferredType('optional'),
}

const isFusable = element => {
  return element.type === 'range' ||
    element.type === 'char' ||
    element.type === 'anyOfChars';
};
const fuseElements = elements => {
  const [fusables, rest] = partition(isFusable, elements);
  const fused = fusables.map(el => {
    if (el.type === 'char' || el.type === 'anyOfChars') {
      return el.value;
    }
    return `${el.value[0]}-${el.value[1]}`;
  }).join('');
  return [fused, rest];
}

const createStackFrame = type => ({ type, quantifier: null, elements: [] });

const assert = (condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
};

// Symbols are used to create private methods
const clone = Symbol('clone');
const getCurrentFrame = Symbol('getCurrentFrame');
const getCurrentElementArray = Symbol('getCurrentElementArray');
const applyQuantifier = Symbol('applyQuantifier');
const evaluate = Symbol('evaluate');
const getRegexPatternAndFlags = Symbol('getRegexBody');
const matchElement = Symbol('matchElement');
const frameCreatingElement = Symbol('frameCreatingElement');
const quantifierElement = Symbol('quantifierElement');

/**
 * SuperExpressive
 * @class
 */
class SuperExpressive {
  constructor() {
    this.state = {
      hasDefinedStart: false,
      hasDefinedEnd: false,
      flags: {
        g: false,
        y: false,
        m: false,
        i: false,
        u: false,
        s: false
      },
      stack: [createStackFrame(t.root)],
      namedGroups: [],
      totalCaptureGroups: 0
    }
  }

  /**
   * Uses the `g` flag on the regular expression, which indicates that it should match multiple values when run on a string.
   * @returns {SuperExpressive}
   */
  get allowMultipleMatches() {
    const next = this[clone]();
    next.state.flags.g = true;
    return next;
  }

  /**
   * Uses the `m` flag on the regular expression, which indicates that it should treat the `.startOfInput` and `.endOfInput` markers as the start and end of lines.
   * @returns {SuperExpressive}
   */
  get lineByLine() {
    const next = this[clone]();
    next.state.flags.m = true;
    return next;
  }

  /**
   * Uses the `i` flag on the regular expression, which indicates that it should treat ignore the uppercase/lowercase distinction when matching.
   * @returns {SuperExpressive}
   */
  get caseInsensitive() {
    const next = this[clone]();
    next.state.flags.i = true;
    return next;
  }

  /**
   * Uses the `y` flag on the regular expression, which indicates that it should create a stateful regular expression that can be resumed from the last match.
   * @returns {SuperExpressive}
   */
  get sticky() {
    const next = this[clone]();
    next.state.flags.y = true;
    return next;
  }

  /**
   * Uses the `u` flag on the regular expression, which indicates that it should use full unicode matching.
   * @returns {SuperExpressive}
   */
  get unicode() {
    const next = this[clone]();
    next.state.flags.u = true;
    return next;
  }

  /**
   * Uses the `s` flag on the regular expression, which indicates that the input should be treated as a single line, where the `.startOfInput` and `.endOfInput` markers explicitly mark the start and end of input, and `.anyChar` also matches newlines.
   * @returns {SuperExpressive}
   */
  get singleLine() {
    const next = this[clone]();
    next.state.flags.s = true;
    return next;
  }

  [matchElement](typeFn) {
    const next = this[clone]();
    next[getCurrentElementArray]().push(next[applyQuantifier](typeFn));
    return next;
  }


  /**
   * Matches any single character. When combined with `.singleLine`, it also matches newlines.
   * @returns {SuperExpressive}
   */
  get anyChar() { return this[matchElement](t.anyChar); }

  /**
   * Matches any whitespace character, including the special whitespace characters: `\r\n\t\f\v`.
   * @returns {SuperExpressive}
   */
  get whitespaceChar() { return this[matchElement](t.whitespaceChar); }

  /**
   * Matches any non-whitespace character, excluding also the special whitespace characters: `\r\n\t\f\v`.
   * @returns {SuperExpressive}
   */
  get nonWhitespaceChar() { return this[matchElement](t.nonWhitespaceChar); }

  /**
   * Matches any digit from `0-9`.
   * @returns {SuperExpressive}
   */
  get digit() { return this[matchElement](t.digit); }

  /**
   * Matches any non-digit.
   * @returns {SuperExpressive}
   */
  get nonDigit() { return this[matchElement](t.nonDigit); }

  /**
   * Matches any alpha-numeric (`a-z`, `A-Z`, `0-9`) characters, as well as `_`.
   * @returns {SuperExpressive}
   */
  get word() { return this[matchElement](t.word); }

  /**
   * Matches any non alpha-numeric (`a-z`, `A-Z`, `0-9`) characters, excluding `_` as well.
   * @returns {SuperExpressive}
   */
  get nonWord() { return this[matchElement](t.nonWord); }

  /**
   * Matches (without consuming any characters) immediately between a character matched by `.word` and a character not matched by `.word` (in either order).
   * @returns {SuperExpressive}
   */
  get wordBoundary() { return this[matchElement](t.wordBoundary); }

  /**
   * Matches (without consuming any characters) at the position between two characters matched by `.word`.
   * @returns {SuperExpressive}
   */
  get nonWordBoundary() { return this[matchElement](t.nonWordBoundary); }

  /**
   * Matches a `\n` character.
   * @returns {SuperExpressive}
   */
  get newline() { return this[matchElement](t.newline); }

  /**
   * Matches a `\r` character.
   * @returns {SuperExpressive}
   */
  get carriageReturn() { return this[matchElement](t.carriageReturn); }

  /**
   * Matches a `\t` character.
   * @returns {SuperExpressive}
   */
  get tab() { return this[matchElement](t.tab); }

  /**
   * Matches a `\u0000` character (ASCII `0`).
   * @returns {SuperExpressive}
   */
  get nullByte() { return this[matchElement](t.nullByte); }

  /**
   * Matches exactly what was previously matched by a namedCapture.
   * @param {string} name
   * @returns {SuperExpressive}
   */
  namedBackreference(name) {
    assert(
      this.state.namedGroups.includes(name),
      `no capture group called "${name}" exists (create one with .namedCapture())`
    );
    return this[matchElement](t.namedBackreference(name));
  }

  /**
   * Matches exactly what was previously matched by a capture or namedCapture using a positional index. Note regex indexes start at 1, so the first capture group has index 1.
   * @param {number} index
   * @returns {SuperExpressive}
   */
  backreference(index) {
    assert(typeof index === 'number', 'index must be a number');
    assert(
      index > 0 && index <= this.state.totalCaptureGroups,
      `invalid index ${index}. There are ${this.state.totalCaptureGroups} capture groups on this SuperExpression`
      );

    return this[matchElement](t.backreference(index));
  }

  [frameCreatingElement](typeFn) {
    const next = this[clone]();
    const newFrame = createStackFrame(typeFn);
    next.state.stack.push(newFrame);
    return next;
  }

  /**
   * Matches a choice between specified elements. Needs to be finalised with `.end()`.
   * @returns {SuperExpressive}
   */
  get anyOf() { return this[frameCreatingElement](t.anyOf); }

  /**
   * Creates a non-capturing group of the proceeding elements. Needs to be finalised with `.end()`.
   * @returns {SuperExpressive}
   */
  get group() { return this[frameCreatingElement](t.group); }

  /**
   * Assert that the proceeding elements are found without consuming them. Needs to be finalised with `.end()`.
   * @returns {SuperExpressive}
   */
  get assertAhead() { return this[frameCreatingElement](t.assertAhead); }

  /**
   * Assert that the proceeding elements are not found without consuming them. Needs to be finalised with `.end()`.
   * @returns {SuperExpressive}
   */
  get assertNotAhead() { return this[frameCreatingElement](t.assertNotAhead); }

  /**
   * Creates a capture group for the proceeding elements. Needs to be finalised with `.end()`.
   * @returns {SuperExpressive}
   */
  get capture() {
    const next = this[clone]();
    const newFrame = createStackFrame(t.capture);
    next.state.stack.push(newFrame);
    next.state.totalCaptureGroups++;
    return next;
  }

  /**
   * Creates a named capture group for the proceeding elements. Needs to be finalised with .end(). Can be later referenced with namedBackreference(name) or backreference(index).
   * @param {string} name 
   * @returns {SuperExpressive}
   */
  namedCapture(name) {
    assert(typeof name === 'string', `name must be a string (got ${name})`);
    assert(name.length > 0, `name must be at least one character`);
    assert(!this.state.namedGroups.includes(name), `cannot use ${name} again for a capture group`);
    assert(namedGroupRegex.test(name), `name is not valid (only letters, numbers, and underscores)`);

    const next = this[clone]();
    const newFrame = createStackFrame(t.namedCapture(name));
    next.state.namedGroups.push(name);
    next.state.stack.push(newFrame);
    next.state.totalCaptureGroups++;
    return next;
  }

  [quantifierElement](typeFnName) {
    const next = this[clone]();
    const currentFrame = next[getCurrentFrame]();
    if (currentFrame.quantifier) {
      throw new Error(`cannot quantify regular expression with "${typeFnName}" because it's already being quantified with "${currentFrame.quantifier.type}"`);
    }
    currentFrame.quantifier = t[typeFnName];
    return next;
  }

  /**
   * Assert that the proceeding element may or may not be matched.
   * @returns {SuperExpressive}
   */
  get optional() { return this[quantifierElement]('optional'); }

  /**
   * Assert that the proceeding element may not be matched, or may be matched multiple times.
   * @returns {SuperExpressive}
   */
  get zeroOrMore() { return this[quantifierElement]('zeroOrMore'); }

  /**
   * Assert that the proceeding element may not be matched, or may be matched multiple times, but as few times as possible.
   * @returns {SuperExpressive}
   */
  get zeroOrMoreLazy() { return this[quantifierElement]('zeroOrMoreLazy'); }

  /**
   * Assert that the proceeding element may be matched once, or may be matched multiple times.
   * @returns {SuperExpressive}
   */
  get oneOrMore() { return this[quantifierElement]('oneOrMore'); }

  /**
   * Uses the g flag on the regular expression, which indicates that it should match multiple values when run on a string.
   * @returns {SuperExpressive}
   */
  get oneOrMoreLazy() { return this[quantifierElement]('oneOrMoreLazy'); }

  /**
   * Assert that the proceeding element will be matched exactly `n` times.
   * @param {number} n
   * @returns {SuperExpressive}
   */
  exactly(n) {
    assert(Number.isInteger(n) && n > 0, `n must be a positive integer (got ${n})`);

    const next = this[clone]();
    const currentFrame = next[getCurrentFrame]();
    if (currentFrame.quantifier) {
      throw new Error(`cannot quantify regular expression with "exactly" because it's already being quantified with "${currentFrame.quantifier.type}"`);
    }
    currentFrame.quantifier = t.exactly(n);
    return next;
  }

  /**
   * Assert that the proceeding element will be matched at least `n` times.
   * @param {number} n
   * @returns {SuperExpressive}
   */
  atLeast(n) {
    assert(Number.isInteger(n) && n > 0, `n must be a positive integer (got ${n})`);

    const next = this[clone]();
    const currentFrame = next[getCurrentFrame]();
    if (currentFrame.quantifier) {
      throw new Error(`cannot quantify regular expression with "atLeast" because it's already being quantified with "${currentFrame.quantifier.type}"`);
    }
    currentFrame.quantifier = t.atLeast(n);
    return next;
  }

  /**
   * Assert that the proceeding element will be matched somewhere between `x` and `y` times.
   * @param {numbers} x 
   * @param {numbers} y 
   * @returns {SuperExpressive}
   */
  between(x, y) {
    assert(Number.isInteger(x) && x >= 0, `x must be an integer (got ${x})`);
    assert(Number.isInteger(y) && y > 0, `y must be an integer greater than 0 (got ${y})`);
    assert(x < y, `x must be less than y (x = ${x}, y = ${y})`);

    const next = this[clone]();
    const currentFrame = next[getCurrentFrame]();
    if (currentFrame.quantifier) {
      throw new Error(`cannot quantify regular expression with "between" because it's already being quantified with "${currentFrame.quantifier.type}"`);
    }
    currentFrame.quantifier = t.between(x, y);
    return next;
  }

  /**
   * Assert that the proceeding element will be matched somewhere between `x` and `y` times, but as few times as possible.
   * @param {numbers} x 
   * @param {numbers} y 
   * @returns {SuperExpressive}
   */
  betweenLazy(x, y) {
    assert(Number.isInteger(x) && x >= 0, `x must be an integer (got ${x})`);
    assert(Number.isInteger(y) && y > 0, `y must be an integer greater than 0 (got ${y})`);
    assert(x < y, `x must be less than y (x = ${x}, y = ${y})`);

    const next = this[clone]();
    const currentFrame = next[getCurrentFrame]();
    if (currentFrame.quantifier) {
      throw new Error(`cannot quantify regular expression with "betweenLazy" because it's already being quantified with "${currentFrame.quantifier.type}"`);
    }
    currentFrame.quantifier = t.betweenLazy(x, y);
    return next;
  }

  /**
   * Assert the start of input, or the start of a line when `.lineByLine` is used.
   * @returns {SuperExpressive}
   */
  get startOfInput() {
    assert(!this.state.hasDefinedStart, 'This regex already has a defined start of input');
    assert(!this.state.hasDefinedEnd, 'Cannot define the start of input after the end of input');

    const next = this[clone]();
    next.state.hasDefinedStart = true;
    next[getCurrentElementArray]().push(t.startOfInput);
    return next;
  }

  /**
   * Assert the end of input, or the end of a line when `.lineByLine` is used.
   * @returns {SuperExpressive}
   */
  get endOfInput() {
    if (this.state.hasDefinedEnd) {
      throw new Error('This regex already has a defined end of input');
    }
    const next = this[clone]();
    next.state.hasDefinedEnd = true;
    next[getCurrentElementArray]().push(t.endOfInput);
    return next;
  }

  /**
   * Matches any of the characters in the provided string `chars`.
   * @param {string} s
   * @returns {SuperExpressive}
   */
  anyOfChars(s) {
    const next = this[clone]();

    const elementValue = t.anyOfChars(escapeSpecial(s));
    const currentFrame = next[getCurrentFrame]();

    currentFrame.elements.push(next[applyQuantifier](elementValue));

    return next;
  }

  /**
   * Signifies the end of a SuperExpressive grouping, such as `.anyOf`, `.group`, or `.capture`.
   * @returns {SuperExpressive}
   */
  end() {
    const next = this[clone]();
    if (next.state.stack.length === 1) {
      throw new Error(`Cannot call end while building the root expression.`);
    }

    const oldFrame = next.state.stack.pop();
    const currentFrame = next[getCurrentFrame]();
    currentFrame.elements.push(next[applyQuantifier](oldFrame.type.value(oldFrame.elements)));
    return next;
  }


  /**
   * Matches any string the same length as `str`, except the characters sequentially defined in `str`
   * @returns {SuperExpressive}
   * @param {string} str
   */
  anythingButString(str) {
    assert(typeof str === 'string', `str must be a string (got ${str})`);
    assert(str.length > 0, `str must have least one character`);

    const next = this[clone]();
    const elementValue = t.anythingButString(escapeSpecial(str));
    const currentFrame = next[getCurrentFrame]();
    currentFrame.elements.push(next[applyQuantifier](elementValue));

    return next;
  }

  /**
   * Matches any character, except any of those in the provided string `chars`.
   * @returns {SuperExpressive}
   * @param {string} chars
   */
  anythingButChars(chars) {
    assert(typeof chars === 'string', `chars must be a string (got ${chars})`);
    assert(chars.length > 0, `chars must have at least one character`);

    const next = this[clone]();
    const elementValue = t.anythingButChars(escapeSpecial(chars));
    const currentFrame = next[getCurrentFrame]();
    currentFrame.elements.push(next[applyQuantifier](elementValue));

    return next;
  }

  /**
   * Matches any character, except those that would be captured by the `.range` specified by `a` and `b`.
   * @param {string|number} a
   * @param {string|number} b
   * @returns {SuperExpressive}
   */
  anythingButRange(a, b) {
    const strA = a.toString();
    const strB = b.toString();

    assert(strA.length === 1, `a must be a single character or number (got ${strA})`);
    assert(strB.length === 1, `b must be a single character or number (got ${strB})`);
    assert(strA.charCodeAt(0) < strB.charCodeAt(0), `a must have a smaller character value than b (a = ${strA.charCodeAt(0)}, b = ${strB.charCodeAt(0)})`);

    const next = this[clone]();
    const elementValue = t.anythingButRange([a, b]);
    const currentFrame = next[getCurrentFrame]();
    currentFrame.elements.push(next[applyQuantifier](elementValue));

    return next;
  }

  /**
   * Matches the exact string `s`.
   * @param {string} s
   * @returns {SuperExpressive}
   */
  string(s) {
    assert(typeof s === 'string', `s must be a string (got ${s})`);
    assert(s.length >= 0, `s cannot be an empty string`);

    const next = this[clone]();
    const elementValue = s.length > 1 ? t.string(escapeSpecial(s)) : t.char(s);
    const currentFrame = next[getCurrentFrame]();
    currentFrame.elements.push(next[applyQuantifier](elementValue));

    return next;
  }

  /**
   * Matches the exact character `c`.
   * @param {string} c
   * @returns {SuperExpressive}
   */
  char(c) {
    assert(typeof c === 'string', `c must be a string (got ${c})`);
    assert(c.length === 1, `char() can only be called with a single character (got ${c})`);

    const next = this[clone]();
    const currentFrame = next[getCurrentFrame]();
    currentFrame.elements.push(next[applyQuantifier](t.char(escapeSpecial(c))));

    return next;
  }

  /**
   * Matches any character that falls between `a` and `b`. Ordering is defined by a characters ASCII or unicode value.
   * @param {string|number} a
   * @param {string|number} b
   * @returns {SuperExpressive}
   */
  range(a, b) {
    const strA = a.toString();
    const strB = b.toString();

    assert(strA.length === 1, `a must be a single character or number (got ${strA})`);
    assert(strB.length === 1, `b must be a single character or number (got ${strB})`);
    assert(strA.charCodeAt(0) < strB.charCodeAt(0), `a must have a smaller character value than b (a = ${strA.charCodeAt(0)}, b = ${strB.charCodeAt(0)})`);

    const next = this[clone]();

    const elementValue = t.range([strA, strB]);
    const currentFrame = next[getCurrentFrame]();

    currentFrame.elements.push(this[applyQuantifier](elementValue));

    return next;
  }

  /**
   * Outputs a string representation of the regular expression that this SuperExpression models.
   * @returns {string}
   * @returns {SuperExpressive}
   */
  toRegexString() {
    const {pattern, flags} = this[getRegexPatternAndFlags]();
    return `/${pattern}/${flags}`;
  }

  /**
   * Outputs a string representation of the regular expression that this SuperExpression models.
   * @returns {RegExp}
   * @returns {SuperExpressive}
   */
  toRegex() {
    const {pattern, flags} = this[getRegexPatternAndFlags]();
    return new RegExp(pattern, flags);
  }

  [getRegexPatternAndFlags]() {
    assert(
      this.state.stack.length === 1,
      'Cannot compute the value of a not yet fully specified regex object.' +
      `\n(Try adding a .end() call to match the "${this[getCurrentFrame]().type.type}")\n`
    );

    const pattern = this[getCurrentElementArray]().map(SuperExpressive[evaluate]).join('');
    const flags = Object.entries(this.state.flags).map(([name, isOn]) => isOn ? name : '').join('');

    return {
      pattern: pattern === '' ? '(?:)' : pattern,
      flags
    };
  }

  [applyQuantifier](element) {
    const currentFrame = this[getCurrentFrame]();
    if (currentFrame.quantifier) {
      const wrapped = currentFrame.quantifier.value(element);
      currentFrame.quantifier = null;
      return wrapped;
    }
    return element;
  }

  [getCurrentFrame]() {
    return this.state.stack[this.state.stack.length - 1];
  }

  [getCurrentElementArray]() {
    return this[getCurrentFrame]().elements;
  }

  [clone]() {
    const next = new SuperExpressive();
    next.state = deepCopy(this.state);
    return next;
  }

  static [evaluate](el) {
    switch (el.type) {
      case 'anyChar': return '.';
      case 'whitespaceChar': return '\\s';
      case 'nonWhitespaceChar': return '\\S';
      case 'digit': return '\\d';
      case 'nonDigit': return '\\D';
      case 'word': return '\\w';
      case 'nonWord': return '\\W';
      case 'wordBoundary': return '\\b';
      case 'nonWordBoundary': return '\\B';
      case 'startOfInput': return '^';
      case 'endOfInput': return '$';
      case 'newline': return '\\n';
      case 'carriageReturn': return '\\r';
      case 'tab': return '\\t';
      case 'nullByte': return '\\0';
      case 'string': return el.value;
      case 'char': return el.value;
      case 'range': return `[${el.value[0]}-${el.value[1]}]`;
      case 'anythingButRange': return `[^${el.value[0]}-${el.value[1]}]`;
      case 'anyOfChars': return `[${el.value}]`;
      case 'anythingButChars': return `[^${el.value}]`;
      case 'namedBackreference': return `\\k<${el.metadata}>`;
      case 'backreference': return `\\${el.metadata}`;

      case 'optional':
      case 'zeroOrMore':
      case 'zeroOrMoreLazy':
      case 'oneOrMore':
      case 'oneOrMoreLazy': {
        const inner = SuperExpressive[evaluate](el.value);
        const withGroup = el.value.quantifierRequiresGroup
          ? `(?:${inner})`
          : inner;
        const symbol = quantifierTable[el.type];
        return `${withGroup}${symbol}`;
      }

      case 'betweenLazy':
      case 'between':
      case 'atLeast':
      case 'exactly': {
        const inner = SuperExpressive[evaluate](el.value);
        const withGroup = el.value.quantifierRequiresGroup
          ? `(?:${inner})`
          : inner;
        return `${withGroup}${quantifierTable[el.type](el.metadata)}`;
      }

      case 'anythingButString': {
        const chars = el.value.split('').map(c => `[^${c}]`).join('');
        return `(?:${chars})`;
      }

      case 'assertAhead': {
        const evaluated = el.value.map(SuperExpressive[evaluate]).join('');
        return `(?=${evaluated})`;
      }

      case 'assertNotAhead': {
        const evaluated = el.value.map(SuperExpressive[evaluate]).join('');
        return `(?!${evaluated})`;
      }

      case 'anyOf': {
        const [fused, rest] = fuseElements(el.value);

        if (!rest.length) {
          return `[${fused}]`;
        }

        const evaluatedRest = rest.map(SuperExpressive[evaluate]);
        const separator = (evaluatedRest.length > 0 && fused.length > 0) ? '|' : '';
        return `(?:${evaluatedRest.join('|')}${separator}${fused ? `[${fused}]` : ''})`;
      }

      case 'capture': {
        const evaluated = el.value.map(SuperExpressive[evaluate]);
        return `(${evaluated.join('')})`;
      }

      case 'namedCapture': {
        const evaluated = el.value.map(SuperExpressive[evaluate]);
        return `(?<${el.metadata}>${evaluated.join('')})`;
      }

      case 'group': {
        const evaluated = el.value.map(SuperExpressive[evaluate]);
        return `(?:${evaluated.join('')})`;
      }

      default: {
        throw new Error(`Can't process unsupported element type: ${el.type}`);
      }
    }
  }

  /**
   * Create an instance of SuperExpressive
   * @returns {SuperExpressive}
   */
  static create() {
    return new SuperExpressive();
  }
}

module.exports = SuperExpressive.create;
